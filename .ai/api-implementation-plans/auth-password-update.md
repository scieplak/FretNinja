# API Endpoint Implementation Plan: POST /api/auth/password-update

## 1. Endpoint Overview

Update the user's password using a recovery token received via email. This endpoint is called after the user clicks the password reset link and is redirected to the password update page. The recovery token is passed in the Authorization header and validated by Supabase.

## 2. Request Details

- **HTTP Method:** POST
- **URL Structure:** `/api/auth/password-update`
- **Parameters:**
  - Required: None (all data in body/header)
  - Optional: None
- **Request Body:**
```json
{
  "password": "newSecurePassword123"
}
```

### Request Headers
- `Content-Type: application/json`
- `Authorization: Bearer <recovery_token>`

## 3. Used Types

### DTOs (from `src/types.ts`)
```typescript
// Input
interface PasswordUpdateCommand {
  password: string;
}

// Output
interface PasswordUpdateResponseDTO {
  message: string;
}

// Errors
interface ApiErrorDTO {
  code: string;
  message: string;
}
```

### Zod Validation Schema (to create)
```typescript
import { z } from 'zod';

export const passwordUpdateCommandSchema = z.object({
  password: z.string().min(8, 'Password must be at least 8 characters'),
});
```

## 4. Response Details

### Success Response (200 OK)
```json
{
  "message": "Password updated successfully"
}
```

### Error Responses

| Status | Code | Message | Scenario |
|--------|------|---------|----------|
| 400 | `VALIDATION_ERROR` | Password must be at least 8 characters | Password too short |
| 401 | `INVALID_TOKEN` | Invalid or expired reset token | Token missing, invalid, or expired |
| 500 | `SERVER_ERROR` | Password update failed | Unexpected Supabase or server error |

## 5. Data Flow

```
┌─────────────┐      ┌─────────────┐      ┌──────────────┐      ┌─────────────┐
│   Client    │─────▶│  API Route  │─────▶│ AuthService  │─────▶│Supabase Auth│
│             │      │  (Astro)    │      │              │      │             │
└─────────────┘      └─────────────┘      └──────────────┘      └─────────────┘
       │                    │                    │                     │
       │                    ▼                    ▼                     ▼
       │             1. Extract token     2. Call updateUser    3. Verify token
       │             2. Validate pass     3. Map errors         4. Update password
       └─────────────3. Call service      4. Return DTO         5. Invalidate token
        Auth Header
```

### Steps:
1. User clicks reset link in email → redirected to `/auth/password-update` with token
2. Frontend extracts token from URL and stores it
3. User enters new password, frontend sends POST with token in header
4. API route validates password length
5. Call `AuthService.updatePassword()` with token and new password
6. Supabase verifies token, updates password, invalidates token
7. Return 200 with success message

## 6. Security Considerations

### Authentication
- Recovery token required in Authorization header
- Token is single-use and time-limited (typically 1 hour)

### Rate Limiting
- 10 requests per 15 minutes per IP (as per API spec for auth endpoints)
- Prevents brute force token guessing

### Token Security
- Token is generated by Supabase with cryptographic randomness
- Token expires after configured time
- Token is invalidated after successful use
- Token should only be transmitted over HTTPS

### Password Security
- Enforce minimum length (8 characters)
- Consider additional complexity requirements (future enhancement)
- Password is hashed by Supabase before storage

### Token Handling Flow
1. Reset email contains link: `/auth/password-update#access_token=xxx&type=recovery`
2. Frontend extracts token from URL hash (not sent to server in URL)
3. Token passed via Authorization header when calling this endpoint

## 7. Error Handling

### Validation Errors
```typescript
// Password too short
if (!validation.success) {
  return new Response(
    JSON.stringify({
      code: 'VALIDATION_ERROR',
      message: 'Password must be at least 8 characters'
    }),
    { status: 400 }
  );
}
```

### Token Errors
```typescript
// Missing or invalid token format
if (!token) {
  return new Response(
    JSON.stringify({ code: 'INVALID_TOKEN', message: 'Invalid or expired reset token' }),
    { status: 401 }
  );
}
```

### Supabase Error Mapping
```typescript
function mapPasswordUpdateError(error: AuthError): { status: number; body: ApiErrorDTO } {
  // Token expired or invalid
  if (error.message.includes('expired') ||
      error.message.includes('invalid') ||
      error.message.includes('token') ||
      error.message.includes('JWT')) {
    return {
      status: 401,
      body: { code: 'INVALID_TOKEN', message: 'Invalid or expired reset token' }
    };
  }

  // Password requirements not met (if Supabase has additional checks)
  if (error.message.includes('password')) {
    return {
      status: 400,
      body: { code: 'VALIDATION_ERROR', message: 'Password must be at least 8 characters' }
    };
  }

  console.error('Password update error:', error.message);
  return {
    status: 500,
    body: { code: 'SERVER_ERROR', message: 'Password update failed' }
  };
}
```

## 8. Performance Considerations

### Potential Bottlenecks
- Supabase Auth API latency
- Password hashing (CPU-intensive, handled by Supabase)

### Optimizations
- Input validation before Supabase call (fail fast)
- Single Supabase call for update

### Caching
- Not applicable for password update endpoint

## 9. Implementation Steps

### Step 1: Add Password Update Schema
Update file: `src/lib/schemas/auth.schemas.ts`
```typescript
import { z } from 'zod';

// ... existing schemas ...

export const passwordUpdateCommandSchema = z.object({
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

export type PasswordUpdateCommandInput = z.infer<typeof passwordUpdateCommandSchema>;
```

### Step 2: Add Password Update Method to Auth Service
Update file: `src/lib/services/auth.service.ts`
```typescript
import type { SupabaseClient } from '../../db/supabase.client';
import type {
  // ... existing imports ...
  PasswordUpdateCommand,
  PasswordUpdateResponseDTO,
  ApiErrorDTO
} from '../../types';

export class AuthService {
  constructor(private supabase: SupabaseClient) {}

  // ... existing methods ...

  async updatePassword(
    command: PasswordUpdateCommand
  ): Promise<{ data?: PasswordUpdateResponseDTO; error?: { status: number; body: ApiErrorDTO } }> {
    // Note: The supabase client should already have the session set from the recovery token
    const { error } = await this.supabase.auth.updateUser({
      password: command.password,
    });

    if (error) {
      return { error: this.mapPasswordUpdateError(error) };
    }

    return {
      data: {
        message: 'Password updated successfully'
      }
    };
  }

  private mapPasswordUpdateError(error: Error): { status: number; body: ApiErrorDTO } {
    const message = error.message.toLowerCase();

    // Token expired or invalid
    if (message.includes('expired') ||
        message.includes('invalid') ||
        message.includes('token') ||
        message.includes('jwt') ||
        message.includes('session')) {
      return {
        status: 401,
        body: { code: 'INVALID_TOKEN', message: 'Invalid or expired reset token' }
      };
    }

    // Password requirements
    if (message.includes('password')) {
      return {
        status: 400,
        body: { code: 'VALIDATION_ERROR', message: 'Password must be at least 8 characters' }
      };
    }

    console.error('Password update error:', error.message);
    return {
      status: 500,
      body: { code: 'SERVER_ERROR', message: 'Password update failed' }
    };
  }

  // ... existing methods ...
}
```

### Step 3: Create API Endpoint
Create file: `src/pages/api/auth/password-update.ts`
```typescript
import type { APIRoute } from 'astro';
import { createClient } from '@supabase/supabase-js';
import { passwordUpdateCommandSchema } from '../../../lib/schemas/auth.schemas';
import { AuthService } from '../../../lib/services/auth.service';
import { extractBearerToken } from '../../../lib/helpers/auth.helper';
import type { Database } from '../../../db/database.types';

export const prerender = false;

export const POST: APIRoute = async ({ request }) => {
  // 1. Extract recovery token from Authorization header
  const authHeader = request.headers.get('Authorization');
  const token = extractBearerToken(authHeader);

  if (!token) {
    return new Response(
      JSON.stringify({ code: 'INVALID_TOKEN', message: 'Invalid or expired reset token' }),
      { status: 401, headers: { 'Content-Type': 'application/json' } }
    );
  }

  // 2. Parse request body
  let body: unknown;
  try {
    body = await request.json();
  } catch {
    return new Response(
      JSON.stringify({ code: 'VALIDATION_ERROR', message: 'Invalid JSON body' }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }

  // 3. Validate input
  const validation = passwordUpdateCommandSchema.safeParse(body);
  if (!validation.success) {
    return new Response(
      JSON.stringify({
        code: 'VALIDATION_ERROR',
        message: validation.error.issues[0].message
      }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    );
  }

  // 4. Create Supabase client with recovery token session
  // Note: We need to create a new client with the recovery token
  const supabaseUrl = import.meta.env.SUPABASE_URL;
  const supabaseAnonKey = import.meta.env.SUPABASE_KEY;

  const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
    global: {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    },
  });

  // 5. Verify token is valid by getting user
  const { data: { user }, error: userError } = await supabase.auth.getUser(token);

  if (userError || !user) {
    return new Response(
      JSON.stringify({ code: 'INVALID_TOKEN', message: 'Invalid or expired reset token' }),
      { status: 401, headers: { 'Content-Type': 'application/json' } }
    );
  }

  // 6. Call service
  const authService = new AuthService(supabase);
  const result = await authService.updatePassword(validation.data);

  // 7. Return response
  if (result.error) {
    return new Response(
      JSON.stringify(result.error.body),
      { status: result.error.status, headers: { 'Content-Type': 'application/json' } }
    );
  }

  return new Response(
    JSON.stringify(result.data),
    { status: 200, headers: { 'Content-Type': 'application/json' } }
  );
};
```

### Step 4: Create Password Update Page (Frontend)
Create file: `src/pages/auth/password-update.astro`
- Extract token from URL hash on client-side
- Show password input form
- Call API with token in Authorization header
- Handle success/error responses

### Step 5: Testing Checklist
- [ ] Valid token + valid password returns 200
- [ ] Valid token + password < 8 chars returns 400 VALIDATION_ERROR
- [ ] Missing token returns 401 INVALID_TOKEN
- [ ] Invalid token returns 401 INVALID_TOKEN
- [ ] Expired token returns 401 INVALID_TOKEN
- [ ] Already used token returns 401 INVALID_TOKEN
- [ ] After success, user can login with new password
- [ ] After success, old password no longer works
- [ ] Empty body returns 400
